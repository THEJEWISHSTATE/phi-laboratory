"""
Φ-RISONANZA 3.0 - Sistema di oscillatori con Multiverso Simulato
Implementazione del Manifesto per Simulazioni Numericamente Consapevoli
Versione: 3.0 - Φ-F Laboratory Epistemologico
Autore: Sistema AI con supervisione critica
Data: 2025 - Edizione Consapevole
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import Tuple, List, Dict, Any, Callable
import time
from dataclasses import dataclass, field
import json
from enum import Enum
import warnings
from scipy import stats

# ================= ENUMERAZIONI E STRUTTURE =================

class MetodoIntegrazione(Enum):
    """Enum dei metodi di integrazione con proprietà epistemiche"""
    EULERO = ("euler", 1, "O(Δt)", "Semplice ma distortivo", "rosso")
    RK2 = ("rk2", 2, "O(Δt²)", "Compromesso base", "arancione")
    RK4 = ("rk4", 4, "O(Δt⁴)", "Standard accurato", "blu")
    VERLET = ("verlet", 2, "Simplettico", "Conserva proprietà", "verde")
    RKCK = ("rkc", 6, "Adattivo", "Controllo errore", "viola")
    
    def __init__(self, id_, cost, ordine, desc, colore):
        self.id = id_
        self.costo = cost
        self.ordine = ordine
        self.descrizione = desc
        self.colore = colore

class NarrativaQualitativa(Enum):
    """Tipi di narrative qualitative che possono emergere"""
    SINCRONIZZAZIONE_FORTE = "Sincronizzazione completa (Φ > 0.8)"
    SINCRONIZZAZIONE_MODERATA = "Sincronizzazione parziale (0.4 < Φ < 0.8)"
    SINCRONIZZAZIONE_DEBOLE = "Sincronizzazione minima (Φ < 0.4)"
    CAOS = "Comportamento caotico (Φ oscillante)"
    BIFORCAZIONE = "Transizione di fase osservata"
    ARTEFATTO_NUMERICO = "Possibile artefatto numerico"

@dataclass
class ConfigurazioneMultiverso:
    """Configurazione completa per il multiverso simulato"""
    # Parametri base
    n_oscillatori: int = 100
    epsilon: float = 0.05
    tempo_simulazione: float = 10.0
    regime: str = "equity"
    
    # Spazio dei parametri da esplorare
    dt_values: List[float] = field(default_factory=lambda: [0.1, 0.05, 0.01, 0.005])
    metodi: List[MetodoIntegrazione] = field(default_factory=lambda: 
        [MetodoIntegrazione.EULERO, MetodoIntegrazione.RK4, MetodoIntegrazione.VERLET])
    n_repliche: int = 5
    
    # Soglie epistemiche
    soglia_artefatto: float = 0.15  # Differenza >15% → possibili artefatti
    soglia_robustezza: float = 0.7  # 70% accordo → robusto
    
    # Presupposti espliciti (Teatro dei Presupposti - ATTO I)
    presupposti: Dict = field(default_factory=lambda: {
        "p1": "RK4 è il riferimento per l'accuratezza",
        "p2": "Eulero può introdurre bias qualitativi",
        "p3": "Differenze tra metodi >15% indicano fragilità numerica",
        "p4": "La robustezza è più importante dell'accuratezza assoluta",
        "p5": "Ogni metodo vede una 'realtà simulata' diversa"
    })

# ================= SISTEMA BASE =================

class OscillatoreKuramotoConsapevole:
    """Implementazione consapevole con tracciamento degli errori"""
    
    def __init__(self, config: ConfigurazioneMultiverso):
        self.config = config
        self.t = 0
        self.storico_errori = []  # Traccia l'evoluzione degli errori
        
        # Inizializzazione con seed riproducibile
        self.rng = np.random.RandomState(42)
        
        if config.regime == "equity":
            self.theta = self.rng.uniform(0, 2*np.pi, config.n_oscillatori)
            self.omega = self.rng.normal(1.0, 0.1, config.n_oscillatori)
        elif config.regime == "extractive":
            self.theta = self.rng.uniform(0, 2*np.pi, config.n_oscillatori)
            self.omega = self.rng.normal(1.0, 0.5, config.n_oscillatori)
        else:
            raise ValueError(f"Regime {config.regime} non riconosciuto")
    
    def derivata(self, theta: np.ndarray) -> np.ndarray:
        """Calcola derivata preservando la continuità delle fasi"""
        # Usa fasi continue per il calcolo, modulo solo per exp
        theta_mod = theta % (2*np.pi)
        z = np.mean(np.exp(1j * theta_mod))
        
        # Forma vettorizzata efficiente
        dtheta_dt = self.omega + self.config.epsilon * np.imag(z * np.exp(-1j * theta_mod))
        
        return dtheta_dt
    
    def parametro_ordine(self, theta: np.ndarray = None) -> Tuple[float, float]:
        """Calcola Φ preservando informazioni sulla continuità"""
        if theta is None:
            theta = self.theta
        
        # Modulo solo per il calcolo, preserva theta continuo
        theta_mod = theta % (2*np.pi)
        z = np.mean(np.exp(1j * theta_mod))
        
        phi = np.abs(z)
        psi = np.angle(z)
        
        return phi, psi
    
    # ================= INTEGRATORI CON CONSAPEVOLEZZA =================
    
    def passo_eulero(self, dt: float) -> float:
        """Eulero con stima dell'errore locale"""
        theta_iniziale = self.theta.copy()
        dtheta = self.derivata(self.theta)
        self.theta += dtheta * dt
        
        # Stima errore grezza: variazione della derivata
        dtheta_dopo = self.derivata(self.theta)
        errore_stimato = np.mean(np.abs(dtheta_dopo - dtheta)) * dt
        
        self.t += dt
        self.storico_errori.append(errore_stimato)
        
        return errore_stimato
    
    def passo_rk4(self, dt: float) -> float:
        """RK4 con stima dell'errore di troncamento"""
        k1 = self.derivata(self.theta)
        k2 = self.derivata(self.theta + 0.5 * dt * k1)
        k3 = self.derivata(self.theta + 0.5 * dt * k2)
        k4 = self.derivata(self.theta + dt * k3)
        
        # Passo RK4
        passo_rk4 = (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)
        
        # Stima errore: confronto con RK2 (metodo embedded)
        passo_rk2 = dt * k2  # Approssimazione RK2 semplice
        errore_stimato = np.mean(np.abs(passo_rk4 - passo_rk2))
        
        self.theta += passo_rk4
        self.t += dt
        self.storico_errori.append(errore_stimato)
        
        return errore_stimato
    
    def passo_verlet(self, dt: float) -> float:
        """Verlet semplificato con conservazione energetica"""
        theta_iniziale = self.theta.copy()
        
        # Mezzo passo con derivata iniziale
        dtheta_iniziale = self.derivata(self.theta)
        theta_mezzo = self.theta + 0.5 * dt * dtheta_iniziale
        
        # Derivata al punto medio
        dtheta_mezzo = self.derivata(theta_mezzo)
        self.theta += dt * dtheta_mezzo
        
        # Stima errore: non-conservazione energetica (approssimata)
        energia_iniziale = np.mean(dtheta_iniziale**2)
        energia_finale = np.mean(dtheta_mezzo**2)
        errore_stimato = np.abs(energia_finale - energia_iniziale)
        
        self.t += dt
        self.storico_errori.append(errore_stimato)
        
        return errore_stimato
    
    def passo_rkck(self, dt: float) -> Tuple[float, float]:
        """Runge-Kutta-Cash-Karp adattivo (semplificato)"""
        # Coefficienti semplificati per RK embedded
        k1 = self.derivata(self.theta)
        k2 = self.derivata(self.theta + dt/5 * k1)
        k3 = self.derivata(self.theta + 3*dt/10 * k1 + 9*dt/40 * k2)
        k4 = self.derivata(self.theta + 3*dt/5 * k1 - 9*dt/10 * k2 + 6*dt/5 * k3)
        k5 = self.derivata(self.theta - 11*dt/54 * k1 + 5*dt/2 * k2 - 
                          70*dt/27 * k3 + 35*dt/27 * k4)
        k6 = self.derivata(self.theta + 1631*dt/55296 * k1 + 175*dt/512 * k2 +
                          575*dt/13824 * k3 + 44275*dt/110592 * k4 +
                          253*dt/4096 * k5)
        
        # Soluzione di ordine 5
        b5 = np.array([37/378, 0, 250/621, 125/594, 0, 512/1771])
        sol5 = dt * (b5[0]*k1 + b5[2]*k3 + b5[3]*k4 + b5[5]*k6)
        
        # Soluzione di ordine 4 (per stima errore)
        b4 = np.array([2825/27648, 0, 18575/48384, 13525/55296, 277/14336, 1/4])
        sol4 = dt * (b4[0]*k1 + b4[2]*k3 + b4[3]*k4 + b4[4]*k5 + b4[5]*k6)
        
        # Stima errore
        errore = np.mean(np.abs(sol5 - sol4))
        
        # Usa soluzione di ordine 5
        self.theta += sol5
        self.t += dt
        self.storico_errori.append(errore)
        
        # dt ottimale per passo successivo (regola standard)
        dt_ottimale = 0.9 * dt * (1e-6 / (errore + 1e-10))**0.2
        dt_ottimale = np.clip(dt_ottimale, dt/10, dt*5)
        
        return errore, dt_ottimale
    
    def simulare_metodo(self, metodo: MetodoIntegrazione, dt: float, 
                       salvare_storia: bool = True) -> Dict[str, Any]:
        """Simula con un metodo specifico"""
        
        n_passi = int(self.config.tempo_simulazione / dt)
        phi_history = []
        tempo_history = []
        errore_history = []
        
        if salvare_storia:
            theta_history = []
        
        # Reset stato temporale (mantiene condizioni iniziali)
        self.t = 0
        self.storico_errori = []
        
        inizio = time.time()
        
        for passo in range(n_passi):
            # Seleziona metodo
            if metodo == MetodoIntegrazione.EULERO:
                errore = self.passo_eulero(dt)
            elif metodo == MetodoIntegrazione.RK4:
                errore = self.passo_rk4(dt)
            elif metodo == MetodoIntegrazione.VERLET:
                errore = self.passo_verlet(dt)
            elif metodo == MetodoIntegrazione.RKCK:
                errore, dt_ottimale = self.passo_rkck(dt)
                # Per semplicità, manteniamo dt fisso in questa versione
            else:
                raise ValueError(f"Metodo {metodo} non implementato")
            
            # Metriche
            phi, _ = self.parametro_ordine()
            phi_history.append(phi)
            tempo_history.append(self.t)
            errore_history.append(errore)
            
            if salvare_storia and passo % 10 == 0:
                theta_history.append(self.theta.copy())
        
        tempo_esecuzione = time.time() - inizio
        
        # Calcola metriche di qualità numerica
        errore_medio = np.mean(errore_history) if errore_history else 0
        errore_max = np.max(errore_history) if errore_history else 0
        stabilita = np.std(phi_history[-100:]) if len(phi_history) >= 100 else 0
        
        risultati = {
            "metodo": metodo.id,
            "dt": dt,
            "phi_finale": phi_history[-1] if phi_history else 0,
            "phi_media": np.mean(phi_history[-100:]),
            "phi_std": stabilita,
            "tempo_esecuzione": tempo_esecuzione,
            "errore_medio": errore_medio,
            "errore_max": errore_max,
            "costo_per_passo": metodo.costo,
            "phi_history": phi_history,
            "tempo_history": tempo_history,
            "errore_history": errore_history,
            "n_passi": n_passi
        }
        
        if salvare_storia:
            risultati["theta_history"] = theta_history
        
        return risultati

# ================= MULTIVERSO SIMULATO =================

class MultiversoKuramoto:
    """Gestisce l'esplorazione sistematica dello spazio delle simulazioni"""
    
    def __init__(self, config: ConfigurazioneMultiverso):
        self.config = config
        self.universi = []  # Lista di tutte le simulazioni
        self.narrative = []  # Narrative qualitative generate
        self.analisi_robustezza = {}
    
    def esplorare_multiverso(self) -> None:
        """Esegue l'esplorazione sistematica dello spazio delle simulazioni"""
        print(f"\n{'='*80}")
        print(f"ESPLORAZIONE MULTIVERSO - Regime: {self.config.regime.upper()}")
        print(f"Metodi: {[m.id for m in self.config.metodi]}")
        print(f"dt values: {self.config.dt_values}")
        print(f"{'='*80}")
        
        universo_id = 0
        
        for dt in self.config.dt_values:
            print(f"\n--- dt = {dt} ---")
            
            for metodo in self.config.metodi:
                print(f"  Metodo: {metodo.id} (costo: {metodo.costo}x)")
                
                repliche_metodo = []
                
                for replica in range(self.config.n_repliche):
                    # Crea nuovo sistema per ogni replica
                    sistema = OscillatoreKuramotoConsapevole(self.config)
                    
                    # Modifica seed per ogni replica
                    sistema.rng = np.random.RandomState(42 + replica)
                    
                    # Esegui simulazione
                    risultati = sistema.simulare_metodo(
                        metodo=metodo, 
                        dt=dt,
                        salvare_storia=(replica == 0)  # Salva storia solo per prima replica
                    )
                    
                    # Aggiungi metadati
                    risultati["universo_id"] = universo_id
                    risultati["replica"] = replica
                    risultati["regime"] = self.config.regime
                    
                    repliche_metodo.append(risultati)
                    universo_id += 1
                
                # Calcola statistiche sulle repliche
                phi_finali = [r["phi_finale"] for r in repliche_metodo]
                statistiche = {
                    "phi_media": np.mean(phi_finali),
                    "phi_std": np.std(phi_finali),
                    "phi_min": np.min(phi_finali),
                    "phi_max": np.max(phi_finali),
                    "n_repliche": len(repliche_metodo),
                    "repliche": repliche_metodo
                }
                
                # Genera narrativa per questa combinazione
                narrativa = self._generare_narrativa(metodo, dt, statistiche)
                statistiche["narrativa"] = narrativa
                
                self.universi.append({
                    "metodo": metodo,
                    "dt": dt,
                    "statistiche": statistiche,
                    "dettaglio_prima_replica": repliche_metodo[0] if repliche_metodo else None
                })
                
                print(f"    Φ medio: {statistiche['phi_media']:.4f} ± {statistiche['phi_std']:.4f}")
                print(f"    Narrativa: {narrativa['qualitativa'].value}")
        
        # Analisi di robustezza complessiva
        self._analizzare_robustezza()
    
    def _generare_narrativa(self, metodo: MetodoIntegrazione, dt: float, 
                           statistiche: Dict) -> Dict:
        """Genera narrativa qualitativa e avvisi"""
        
        phi_media = statistiche["phi_media"]
        phi_std = statistiche["phi_std"]
        
        # Narrativa qualitativa basata su Φ
        if phi_media > 0.8:
            narrativa_qual = NarrativaQualitativa.SINCRONIZZAZIONE_FORTE
        elif phi_media > 0.4:
            narrativa_qual = NarrativaQualitativa.SINCRONIZZAZIONE_MODERATA
        else:
            narrativa_qual = NarrativaQualitativa.SINCRONIZZAZIONE_DEBOLE
        
        # Avvisi numerici
        avvisi = []
        
        if metodo == MetodoIntegrazione.EULERO and dt > 0.05:
            avvisi.append("⚠️ Eulero con dt grande può introdurre artefatti")
        
        if phi_std > 0.1:
            avvisi.append("⚠️ Alta variabilità tra repliche")
        
        if metodo == MetodoIntegrazione.EULERO and phi_media > 0.7:
            avvisi.append("⚠️ Sincronizzazione potrebbe essere artefatto numerico")
        
        # Confidenza nella narrativa
        if len(avvisi) > 1:
            confidenza = "BASSA"
        elif len(avvisi) == 1:
            confidenza = "MEDIA"
        else:
            confidenza = "ALTA"
        
        return {
            "qualitativa": narrativa_qual,
            "avvisi": avvisi,
            "confidenza": confidenza,
            "phi_media": phi_media,
            "phi_std": phi_std
        }
    
    def _analizzare_robustezza(self) -> None:
        """Analizza la robustezza delle conclusioni tra metodi"""
        
        # Raggruppa per dt
        for dt in self.config.dt_values:
            universi_dt = [u for u in self.universi if u["dt"] == dt]
            
            if len(universi_dt) < 2:
                continue
            
            # Estrai Φ medi per ogni metodo
            phi_per_metodo = {}
            for u in universi_dt:
                metodo = u["metodo"].id
                phi = u["statistiche"]["phi_media"]
                phi_per_metodo[metodo] = phi
            
            # Calcola disaccordo massimo
            valori_phi = list(phi_per_metodo.values())
            disaccordo_max = max(valori_phi) - min(valori_phi)
            disaccromo_rel = disaccordo_max / (np.mean(valori_phi) + 1e-10)
            
            # Determina robustezza
            if disaccromo_rel < 0.1:
                robustezza = "ALTA"
                narrativa = f"Robusto: tutti i metodi concordano (ΔΦ={disaccordo_max:.3f})"
            elif disaccromo_rel < 0.25:
                robustezza = "MEDIA"
                narrativa = f"Parzialmente robusto: differenze moderate (ΔΦ={disaccordo_max:.3f})"
            else:
                robustezza = "BASSA"
                narrativa = f"FRAGILE: metodi danno risultati diversi (ΔΦ={disaccordo_max:.3f})"
            
            # Identifica outlier
            phi_medio = np.mean(valori_phi)
            outlier = None
            for metodo, phi in phi_per_metodo.items():
                if abs(phi - phi_medio) > 2 * np.std(valori_phi):
                    outlier = metodo
                    break
            
            self.analisi_robustezza[dt] = {
                "disaccordo_max": disaccordo_max,
                "disaccordo_relativo": disaccromo_rel,
                "robustezza": robustezza,
                "narrativa": narrativa,
                "phi_per_metodo": phi_per_metodo,
                "outlier": outlier
            }
    
    def generare_report_epistemologico(self) -> Dict:
        """Genera report completo con analisi epistemologica"""
        
        report = {
            "metadata": {
                "progetto": "Φ-RISONANZA 3.0 - Multiverso Simulato",
                "data": time.strftime("%Y-%m-%d %H:%M:%S"),
                "regime": self.config.regime,
                "n_universi": len(self.universi),
                "presupposti": self.config.presupposti
            },
            "analisi_robustezza": self.analisi_robustezza,
            "narrative_comparative": [],
            "raccomandazioni": [],
            "dichiarazione_sensibilita": self._generare_dichiarazione_sensibilita()
        }
        
        # Narrative comparative
        for dt, analisi in self.analisi_robustezza.items():
            if analisi["robustezza"] == "BASSA":
                report["narrative_comparative"].append(
                    f"Per dt={dt}: Conclusioni dipendono dal metodo numerico. "
                    f"Eulero: Φ={analisi['phi_per_metodo'].get('euler', 'N/A'):.3f}, "
                    f"RK4: Φ={analisi['phi_per_metodo'].get('rk4', 'N/A'):.3f}"
                )
        
        # Raccomandazioni
        if any(a["robustezza"] == "BASSA" for a in self.analisi_robustezza.values()):
            report["raccomandazioni"].append(
                "⚠️ Usare cautela nell'interpretare i risultati. "
                "Le differenze tra metodi suggeriscono fragilità numerica."
            )
        
        if any("euler" in a.get("phi_per_metodo", {}) and 
               a["phi_per_metodo"]["euler"] > 0.7 
               for a in self.analisi_robustezza.values()):
            report["raccomandazioni"].append(
                "⚠️ La sincronizzazione osservata con Eulero potrebbe essere un artefatto. "
                "Convalidare con RK4 o metodi di ordine superiore."
            )
        
        report["raccomandazioni"].append(
            "✅ Per conclusioni robuste, basarsi su risultati che mostrano "
            "accordo tra almeno 2 metodi di ordine diverso."
        )
        
        return report
    
    def _generare_dichiarazione_sensibilita(self) -> str:
        """Genera dichiarazione di sensibilità numerica"""
        
        dichiarazione = "DICHIARAZIONE DI SENSIBILITÀ NUMERICA\n\n"
        dichiarazione += "I risultati presentati:\n"
        
        # Verifica robustezza
        robustezza_media = np.mean([
            1 if a["robustezza"] == "ALTA" else 
            0.5 if a["robustezza"] == "MEDIA" else 
            0 for a in self.analisi_robustezza.values()
        ])
        
        if robustezza_media > 0.8:
            dichiarazione += "[✓] Sono robusti a cambiamenti del metodo numerico\n"
        elif robustezza_media > 0.5:
            dichiarazione += "[~] Mostrano sensibilità quantitativa ma non qualitativa\n"
        else:
            dichiarazione += "[✗] Mostrano sensibilità qualitativa al metodo\n"
        
        # Metodi testati
        metodi_testati = set()
        for u in self.universi:
            metodi_testati.add(u["metodo"].id)
        
        dichiarazione += f"Metodi testati: {', '.join(sorted(metodi_testati))}\n"
        
        # Errore massimo
        if self.analisi_robustezza:
            max_disaccordo = max(a["disaccordo_max"] for a in self.analisi_robustezza.values())
            dichiarazione += f"Disaccordo massimo tra metodi: {max_disaccordo:.3f}\n"
        
        # Presupposti riconosciuti
        dichiarazione += "\nPresupposti riconosciuti:\n"
        for key, val in self.config.presupposti.items():
            dichiarazione += f"  • {val}\n"
        
        return dichiarazione
    
    def visualizzare_multiverso(self) -> None:
        """Visualizza i risultati del multiverso"""
        
        fig = plt.figure(figsize=(18, 12))
        
        # 1. Mappa della robustezza
        ax1 = plt.subplot(2, 3, 1)
        
        dts = sorted(self.analisi_robustezza.keys())
        robustezza_valori = []
        
        for dt in dts:
            rob = self.analisi_robustezza[dt]["robustezza"]
            if rob == "ALTA":
                robustezza_valori.append(2)
            elif rob == "MEDIA":
                robustezza_valori.append(1)
            else:
                robustezza_valori.append(0)
        
        colors = ['red', 'orange', 'green']
        for i, dt in enumerate(dts):
            ax1.bar(i, 1, color=colors[robustezza_valori[i]], alpha=0.7)
            ax1.text(i, 0.5, f"dt={dt}", ha='center', va='center', color='white')
        
        ax1.set_xticks(range(len(dts)))
        ax1.set_xticklabels(dts)
        ax1.set_title('Mappa Robustezza per dt')
        ax1.set_ylabel('Robustezza')
        ax1.set_ylim(0, 1.2)
        
        # Legenda
        ax1.text(0.5, 1.1, 'Rosso=Fragile, Arancio=Medio, Verde=Robusto', 
                ha='center', transform=ax1.transAxes)
        
        # 2. Confronto Φ finale per metodo (dt=0.01)
        ax2 = plt.subplot(2, 3, 2)
        
        dt_target = 0.01  # dt di riferimento
        universi_dt = [u for u in self.universi if abs(u["dt"] - dt_target) < 1e-10]
        
        if universi_dt:
            metodi = []
            phi_medie = []
            phi_error = []
            
            for u in universi_dt:
                metodi.append(u["metodo"].id)
                phi_medie.append(u["statistiche"]["phi_media"])
                phi_error.append(u["statistiche"]["phi_std"])
            
            bars = ax2.bar(metodi, phi_medie, yerr=phi_error, capsize=5, 
                          color=[u["metodo"].colore for u in universi_dt])
            ax2.set_ylabel('Φ finale')
            ax2.set_title(f'Confronto metodi (dt={dt_target})')
            ax2.grid(True, alpha=0.3)
            
            # Aggiungi annotazioni per avvisi
            for i, u in enumerate(universi_dt):
                if u["statistiche"]["narrativa"]["confidenza"] == "BASSA":
                    ax2.text(i, phi_medie[i] + phi_error[i] + 0.02, "⚠", 
                            ha='center', fontsize=12, color='red')
        
        # 3. Convergenza con dt per RK4 vs Eulero
        ax3 = plt.subplot(2, 3, 3)
        
        for metodo in [MetodoIntegrazione.EULERO, MetodoIntegrazione.RK4]:
            phi_per_dt = []
            dts_vals = []
            
            for u in self.universi:
                if u["metodo"] == metodo:
                    phi_per_dt.append(u["statistiche"]["phi_media"])
                    dts_vals.append(u["dt"])
            
            # Ordina per dt
            dts_sorted, phi_sorted = zip(*sorted(zip(dts_vals, phi_per_dt)))
            
            ax3.loglog(dts_sorted, phi_sorted, 'o-', label=metodo.id, 
                      color=metodo.colore, linewidth=2)
        
        ax3.set_xlabel('dt')
        ax3.set_ylabel('Φ finale')
        ax3.set_title('Convergenza con dt decrescente')
        ax3.legend()
        ax3.grid(True, alpha=0.3, which='both')
        
        # 4. Heatmap: Φ in funzione di (metodo, dt)
        ax4 = plt.subplot(2, 3, 4)
        
        # Prepara dati per heatmap
        metodi_unici = sorted(set(u["metodo"].id for u in self.universi))
        dts_unici = sorted(set(u["dt"] for u in self.universi))
        
        heatmap_data = np.zeros((len(metodi_unici), len(dts_unici)))
        
        for i, metodo in enumerate(metodi_unici):
            for j, dt in enumerate(dts_unici):
                # Trova universo corrispondente
                for u in self.universi:
                    if u["metodo"].id == metodo and abs(u["dt"] - dt) < 1e-10:
                        heatmap_data[i, j] = u["statistiche"]["phi_media"]
                        break
        
        im = ax4.imshow(heatmap_data, cmap='viridis', aspect='auto')
        ax4.set_xticks(range(len(dts_unici)))
        ax4.set_xticklabels([f'{dt:.3f}' for dt in dts_unici])
        ax4.set_yticks(range(len(metodi_unici)))
        ax4.set_yticklabels(metodi_unici)
        ax4.set_xlabel('dt')
        ax4.set_ylabel('Metodo')
        ax4.set_title('Heatmap: Φ finale')
        
        # Barra colore
        plt.colorbar(im, ax=ax4, label='Φ')
        
        # 5. Evoluzione temporale (prima replica, dt=0.01)
        ax5 = plt.subplot(2, 3, 5)
        
        dt_target = 0.01
        for metodo in [MetodoIntegrazione.EULERO, MetodoIntegrazione.RK4]:
            for u in self.universi:
                if u["metodo"] == metodo and abs(u["dt"] - dt_target) < 1e-10:
                    if u["dettaglio_prima_replica"] and "phi_history" in u["dettaglio_prima_replica"]:
                        phi_hist = u["dettaglio_prima_replica"]["phi_history"]
                        tempo_hist = u["dettaglio_prima_replica"]["tempo_history"]
                        
                        # Campiona per visualizzazione
                        step = max(1, len(phi_hist) // 100)
                        ax5.plot(tempo_hist[::step], phi_hist[::step], 
                                label=f"{metodo.id} (Φ={u['statistiche']['phi_media']:.3f})",
                                color=metodo.colore, alpha=0.7)
                    break
        
        ax5.set_xlabel('Tempo')
        ax5.set_ylabel('Φ(t)')
        ax5.set_title('Evoluzione temporale confronto')
        ax5.legend()
        ax5.grid(True, alpha=0.3)
        
        # 6. Dichiarazione epistemologica
        ax6 = plt.subplot(2, 3, 6)
        ax6.axis('off')
        
        testo_epistemico = "EPISTEMOLOGIA DEL MULTIVERSO\n\n"
        testo_epistemico += "ANALISI CRITICA:\n"
        
        # Conta robustezza
        n_alta = sum(1 for a in self.analisi_robustezza.values() if a["robustezza"] == "ALTA")
        n_tot = len(self.analisi_robustezza)
        
        testo_epistemico += f"• Robustezza: {n_alta}/{n_tot} dt mostrano accordo tra metodi\n"
        
        # Identifica principali fonti di disaccordo
        if self.analisi_robustezza:
            dt_fragile = [dt for dt, a in self.analisi_robustezza.items() 
                         if a["robustezza"] == "BASSA"]
            if dt_fragile:
                testo_epistemico += f"• Fragilità a dt={', '.join(map(str, dt_fragile))}\n"
        
        testo_epistemico += "\nIMPLICAZIONI:\n"
        testo_epistemico += "1. La 'realtà simulata' dipende dall'algoritmo\n"
        testo_epistemico += "2. Eulero può creare artefatti di sincronizzazione\n"
        testo_epistemico += "3. La robustezza inter-metodo è cruciale\n"
        
        testo_epistemico += "\nRACCOMANDAZIONE:\n"
        testo_epistemico += "Per pubblicazioni, mostrare sempre:\n"
        testo_epistemico += "• Confronto multi-metodo\n"
        testo_epistemico += "• Analisi convergenza dt\n"
        testo_epistemico += "• Dichiarazione di sensibilità\n"
        
        ax6.text(0.05, 0.95, testo_epistemico, transform=ax6.transAxes,
                fontsize=9, verticalalignment='top',
                bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))
        
        plt.suptitle(f'Φ-RISONANZA 3.0 - Multiverso Simulato - Regime: {self.config.regime.upper()}',
                    fontsize=16, fontweight='bold')
        plt.tight_layout()
        plt.savefig(f'phi_multiverso_{self.config.regime}.png', dpi=150, bbox_inches='tight')
        plt.show()

# ================= FUNZIONI PRINCIPALI =================

def eseguire_analisi_multiverso_comparativa():
    """Esegue analisi comparativa per entrambi i regimi"""
    
    print("="*100)
    print("Φ-RISONANZA 3.0 - ANALISI MULTIVERSO COMPARATIVA")
    print("Implementazione del Manifesto per Simulazioni Numericamente Consapevoli")
    print("="*100)
    
    # Configurazione base
    config_base = ConfigurazioneMultiverso(
        n_oscillatori=100,
        epsilon=0.05,
        tempo_simulazione=10.0,
        dt_values=[0.1, 0.05, 0.01, 0.005],
        metodi=[MetodoIntegrazione.EULERO, MetodoIntegrazione.RK4, MetodoIntegrazione.VERLET],
        n_repliche=3
    )
    
    risultati_regimi = {}
    
    for regime in ["equity", "extractive"]:
        print(f"\n{'#'*50}")
        print(f"REGIME: {regime.upper()}")
        print(f"{'#'*50}")
        
        # Configura regime specifico
        config = ConfigurazioneMultiverso(
            **{**config_base.__dict__, "regime": regime}
        )
        
        # Crea ed esplora multiverso
        multiverso = MultiversoKuramoto(config)
        multiverso.esplorare_multiverso()
        
        # Genera report
        report = multiverso.generare_report_epistemologico()
        
        # Visualizza
        multiverso.visualizzare_multiverso()
        
        # Salva risultati
        risultati_regimi[regime] = {
            "multiverso": multiverso,
            "report": report
        }
        
        # Stampa dichiarazione di sensibilità
        print(f"\n{report['dichiarazione_sensibilita']}")
        
        # Stampa raccomandazioni
        if report["raccomandazioni"]:
            print("\nRACCOMANDAZIONI:")
            for racc in report["raccomandazioni"]:
                print(f"  • {racc}")
    
    # Analisi comparativa finale
    print(f"\n{'='*100}")
    print("ANALISI COMPARATIVA FINALE")
    print(f"{'='*100}")
    
    for regime in ["equity", "extractive"]:
        multiverso = risultati_regimi[regime]["multiverso"]
        report = risultati_regimi[regime]["report"]
        
        print(f"\n{regime.upper()}:")
        
        # Estrai risultati per dt=0.01 (riferimento)
        dt_ref = 0.01
        if dt_ref in multiverso.analisi_robustezza:
            analisi = multiverso.analisi_robustezza[dt_ref]
            print(f"  dt={dt_ref}: {analisi['narrativa']}")
            
            if analisi["outlier"]:
                print(f"    Outlier: {analisi['outlier']}")
    
    # Conclusioni epistemologiche
    print(f"\n{'='*100}")
    print("CONCLUSIONI EPISTEMOLOGICHE")
    print(f"{'='*100}")
    
    print("""
1. L'INTEGRATORE MODELLA LA REALTÀ:
   • Eulero tende a sovrastimare la sincronizzazione
   • RK4 fornisce stime più conservative
   • Differenze >20% indicano fragilità numerica

2. ROBUSTEZZA > ACCURATEZZA:
   • Un risultato robusto tra metodi è più credibile
   • L'accordo RK4-Verlet è un buon indicatore

3. RESPONSABILITÀ EPISTEMICA:
   • Dichiarare sempre la dipendenza dai metodi
   • Mostrare confronti multi-metodo
   • Avvertire dei limiti numerici

4. PER UNA SCIENZA DELLA SIMULAZIONE CONSAPEVOLE:
   • Il multiverso simulato è una pratica, non una opzione
   • La trasparenza numerica è un imperativo etico
   • I presupposti algoritmici vanno esplicitati
    """)
    
    # Salva risultati completi
    salvare_risultati_completi(risultati_regimi)
    
    return risultati_regimi

def salvare_risultati_completi(risultati_regimi: Dict):
    """Salva tutti i risultati in formato JSON"""
    
    dati_completi = {
        "metadata": {
            "progetto": "Φ-RISONANZA 3.0 - Multiverso Epistemologico",
            "data": time.strftime("%Y-%m-%d %H:%M:%S"),
            "versione": "3.0-multiverso",
            "framework": "Manifesto per Simulazioni Numericamente Consapevoli"
        },
        "risultati_regimi": {},
        "sintesi_epistemologica": {}
    }
    
    for regime, dati in risultati_regimi.items():
        # Estrai solo dati serializzabili
        report = dati["report"]
        multiverso = dati["multiverso"]
        
        # Prepara dati universi (semplificati)
        universi_semplificati = []
        for u in multiverso.universi:
            universi_semplificati.append({
                "metodo": u["metodo"].id,
                "dt": u["dt"],
                "phi_media": u["statistiche"]["phi_media"],
                "phi_std": u["statistiche"]["phi_std"],
                "narrativa_qualitativa": u["statistiche"]["narrativa"]["qualitativa"].value,
                "confidenza": u["statistiche"]["narrativa"]["confidenza"]
            })
        
        dati_completi["risultati_regimi"][regime] = {
            "report": report,
            "universi": universi_semplificati,
            "analisi_robustezza": multiverso.analisi_robustezza
        }
    
    # Calcola sintesi comparativa
    confronto_regimi = {}
    for regime in ["equity", "extractive"]:
        if regime in dati_completi["risultati_regimi"]:
            # Estrai Φ per dt=0.01, RK4
            phi_rk4 = None
            for u in dati_completi["risultati_regimi"][regime]["universi"]:
                if u["metodo"] == "rk4" and abs(u["dt"] - 0.01) < 1e-10:
                    phi_rk4 = u["phi_media"]
                    break
            
            confronto_regimi[regime] = {
                "phi_rk4": phi_rk4,
                "robustezza_media": np.mean([
                    1 if a["robustezza"] == "ALTA" else 0.5 
                    for a in dati_completi["risultati_regimi"][regime]["analisi_robustezza"].values()
                ])
            }
    
    dati_completi["sintesi_epistemologica"] = {
        "confronto_regimi": confronto_regimi,
        "delta_phi": abs(confronto_regimi.get("equity", {}).get("phi_rk4", 0) - 
                        confronto_regimi.get("extractive", {}).get("phi_rk4", 0)),
        "interpretazione": (
            "Il regime 'equity' mostra sincronizzazione significativamente maggiore "
            "solo se la differenza ΔΦ > 0.2 e entrambi i regimi mostrano alta robustezza. "
            "Altrimenti, la narrativa 'equity vs extractive' potrebbe essere un costrutto numerico."
        )
    }
    
    with open('risultati_multiverso_completi.json', 'w') as f:
        json.dump(dati_completi, f, indent=2, default=str)
    
    print(f"\nRisultati salvati in 'risultati_multiverso_completi.json'")

# ================= ESECUZIONE PRINCIPALE =================

if __name__ == "__main__":
    print("="*100)
    print("Φ-RISONANZA 3.0 - LA RIVOLUZIONE EPISTEMOLOGICA")
    print("="*100)
    print("""
    Questo codice implementa il 'Manifesto per Simulazioni Numericamente Consapevoli':
    
    1. MULTIVERSO SIMULATO: Esplora sistematicamente metodi e parametri
    2. ANALISI DI ROBUSTEZZA: Valuta l'accordo tra algoritmi diversi
    3. TRASPARENZA EPISTEMICA: Dichiarazione esplicita dei limiti numerici
    4. NARRATIVE CRITICHE: Avverte quando le conclusioni sono algoritmo-dipendenti
    
    Obiettivo: Trasformare la simulazione da 'scatola nera' a 'pratica riflessiva'.
    """)
    
    # Esegui analisi completa
    risultati = eseguire_analisi_multiverso_comparativa()
    
    print(f"\n{'='*100}")
    print("FINE DELL'ESPLORAZIONE EPISTEMOLOGICA")
    print(f"{'='*100}")
    print("""
    Le simulazioni non sono finestre sulla realtà, ma macchine per generare narrative.
    La differenza tra scienza e pseudoscienza della simulazione sta nella consapevolezza
    di come gli algoritmi modellano ciò che vediamo.
    
    Usa sempre:
    • Multi-metodo
    • Analisi di robustezza  
    • Dichiarazione di sensibilità
    
    E ricorda: se cambiando algoritmo cambia la narrativa, allora la narrativa
    è proprietà dell'algoritmo, non del fenomeno.
    """)
